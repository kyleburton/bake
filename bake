#!/bin/bash
set -eEuo pipefail

BAKE_VERSION="1.0.15"
BAKE_STDOUT_IS_TERMINAL=""
BAKE_COLOR_NORMAL=""
BAKE_COLOR_RED=""
BAKE_COLOR_LRED=""
BAKE_COLOR_BLUE=""
BAKE_COLOR_LBLUE=""
BAKE_COLOR_GREEN=""
BAKE_COLOR_LGREEN=""
BAKE_COLOR_YELLOW=""
BAKE_COLOR_MAGENTA=""
BAKE_COLOR_LMAGENTA=""
BAKE_COLOR_CYAN=""
BAKE_COLOR_LCYAN=""
BAKE_COLOR_LGRAY=""
BAKE_COLOR_DGRAY=""
BAKE_URL="https://raw.githubusercontent.com/kyleburton/bake/master/bake"

BAKE_LOG_LEVEL_NONE=0     # none
BAKE_LOG_LEVEL_FATAL=1    # fatal
BAKE_LOG_LEVEL_ERROR=2    # error
BAKE_LOG_LEVEL_WARN=3     # warn
BAKE_LOG_LEVEL_INFO=4     # info
BAKE_LOG_LEVEL_DEBUG=5    # debug
BAKE_LOG_LEVEL_INTERNAL=6 # internal
BAKE_LOG_LEVEL="${BAKE_LOG_LEVEL:-$BAKE_LOG_LEVEL_INFO}"

# BAKEPATH
#
#  The list of directories that bake will search when resolving libraries (via require)
#
BAKEPATH="${BAKEPATH:-}"

BAKE_PACKAGES_PATH="$HOME/.bake/packages"

BAKE_DEFAULT_TASK=""
declare -A BAKE_TASKS
declare -A BAKE_TASK_DESCRIPTIONS
declare -A BAKE_LIBS

# @api.bake_push_libdir|DESCRIPTION
# @api.bake_push_libdir|  Push a library path on the front of BAKEPATH (searched first).
# @api.bake_push_libdir|ARGUMENTS
# @api.bake_push_libdir|  path  - the path to prepend to BAKEPATH
# @api.bake_push_libdir|RETURNS
# @api.bake_push_libdir|  0 on success
function bake_push_libdir () {
    local path
    path="$1"
    export BAKEPATH="$path:$BAKEPATH"
}

# @api.bake_add_libdir|DESCRIPTION
# @api.bake_add_libdir|  Push a library path on the end of BAKEPATH (searched last).
# @api.bake_add_libdir|ARGUMENTS
# @api.bake_add_libdir|  path - the path to append to BAKEPATH
# @api.bake_add_libdir|RETURNS
# @api.bake_add_libdir|  0 on success
function bake_add_libdir () {
    local path
    path="$1"
    export BAKEPATH="$BAKEPATH:$path"
}

# @api.bake_default_task|DESCRIPTION
# @api.bake_default_task|  Sets the default task to run if the user runs `bake` with no arguments.
# @api.bake_default_task|ARGUMENTS
# @api.bake_default_task|  task  - the name of the task that will be run by default
# @api.bake_default_task|RETURNS
# @api.bake_default_task|  0 on success
function bake_default_task () {
    local task
    task="$1"
    export BAKE_DEFAULT_TASK="$task"
}

# @api.bake_root_dir|DESCRIPTION
# @api.bake_root_dir|  computes and prints the directory of the `bake` command.
# @api.bake_root_dir|ARGUMENTS
# @api.bake_root_dir|  none
# @api.bake_root_dir|RETURNS
# @api.bake_root_dir|  0 on success
function bake_root_dir () {
    # see: http://stackoverflow.com/questions/4774054/reliable-way-for-a-bash-script-to-get-the-full-path-to-itself
    pushd "$(dirname "$0")" > /dev/null
    local BAKE_ROOT_DIR
    BAKE_ROOT_DIR="$(pwd)"
    popd > /dev/null
    echo "$BAKE_ROOT_DIR"
}

# @api.bake_bakefile_dir|DESCRIPTION
# @api.bake_bakefile_dir|  prints the directory of the BAKEFILE
# @api.bake_bakefile_dir|ARGUMENTS
# @api.bake_bakefile_dir|  none
# @api.bake_bakefile_dir|RETURNS
# @api.bake_bakefile_dir|  0 on success
function bake_bakefile_dir () {
    dirname "$BAKEFILE"
}

BAKE_ROOT_DIR="$(bake_root_dir)"

# @api.bake_looks_like_git|DESCRIPTION
# @api.bake_looks_like_git|  tests if the argument looks like a git@host:org/repo.git url
# @api.bake_looks_like_git|ARGUMENTS
# @api.bake_looks_like_git|  url - the url to test
# @api.bake_looks_like_git|RETURNS
# @api.bake_looks_like_git|  0 on success
# @api.bake_looks_like_git|  1 if the argument does not start with `git@`
function bake_looks_like_git () {
    [[ ${1:-} == git@* ]]
}

# @api.bake_looks_like_url|DESCRIPTION
# @api.bake_looks_like_url|  tests if the argument looks like a URL supported by bake_require
# @api.bake_looks_like_url|ARGUMENTS
# @api.bake_looks_like_url|  url - the url to test
# @api.bake_looks_like_url|RETURNS
# @api.bake_looks_like_url|  0 if the url looks like an http, https, or ssh url or starts with `github.com`
# @api.bake_looks_like_url|  1 otherwise
function bake_looks_like_url () {
    [[     "${1:-}" == http://*     ]] || \
        [[ "${1:-}" == https://*    ]] || \
        [[ "${1:-}" == github.com/* ]] || \
        [[ "${1:-}" == ssh://*      ]]
}

# @api.bake_source_from_fs|DESCRIPTION
# @api.bake_source_from_fs|  load a library from a file in the file system.
# @api.bake_source_from_fs|  loaded files are added to the BAKE_LIBS associative array.
# @api.bake_source_from_fs|ARGUMENTS
# @api.bake_source_from_fs|  file   - the file to be sourced
# @api.bake_source_from_fs|  fname  - the absolute path to the file, may be different from file, when
# @api.bake_source_from_fs|           file is from one of the directories in the BAKEPATH
# @api.bake_source_from_fs|RETURNS
# @api.bake_source_from_fs|  0 on success, after the file has been sourced
function bake_source_from_fs () {
    local file fname
    file="$1"
    fname="$2"
    # shellcheck disable=SC2034
    BAKE_LIBS["$file"]="$fname"
    # shellcheck disable=SC2064
    trap "bake_echo_red 'Error[bake_require_from_fs] loading require: $fname'" EXIT
    # shellcheck disable=SC1090
    source "$fname"
    trap EXIT # clear the trap
    return 0
}

# @api.bake_require_from_fs|DESCRPTION
# @api.bake_require_from_fs|  load a library from the file system, attempting the followng options, in order:
# @api.bake_require_from_fs|  * literal path
# @api.bake_require_from_fs|  * located under $(bake_bakefile_dir)
# @api.bake_require_from_fs|  * in any of the directories in $BAKEPATH
# @api.bake_require_from_fs|ARGUMENTS
# @api.bake_require_from_fs|  file - the file to require
# @api.bake_require_from_fs|RETURNS
# @api.bake_require_from_fs|  0 on success
# @api.bake_require_from_fs|  throws if the file can not be found
function bake_require_from_fs () {
    local file fname
    file="$1"

    if [[ -e "$file" ]]; then
        bake_source_from_fs "$file" "$file"
        return 0
    fi

    if [[ -e "$(bake_bakefile_dir)/$file" ]]; then
        bake_source_from_fs "$file" "$(bake_bakefile_dir)/$file"
        return 0
    fi

    for path in $(echo "$BAKEPATH" | tr : ' '); do
        fname="$path/$file"
        if [ -e "$fname" ]; then
            bake_source_from_fs "$file" "$fname"
            return 0
        fi

        fname="$path/$file.sh"
        if [ -e "$fname" ]; then
            bake_source_from_fs "$file" "$fname"
            return 0
        fi
    done

    bake_throw "Error[bake_require_from_fs]: unable to require $file! (not found on BAKEPATH)"
}

# @api.bake_url_to_package_path|DESCRPTION
# @api.bake_url_to_package_path|  convert `url` into a local package path
# @api.bake_url_to_package_path|
# @api.bake_url_to_package_path|  * strip prefix up to and including `://`
# @api.bake_url_to_package_path|  * strip prefix up to and including `git@`
# @api.bake_url_to_package_path|
# @api.bake_url_to_package_path|  prints $BAKE_PACKAGES_PATH/<stripped-url>
# @api.bake_url_to_package_path|
# @api.bake_url_to_package_path|    bake_url_to_package_path "git@github.com:kyleburton/bake-recipes.git"
# @api.bake_url_to_package_path|      => $BAKE_PACKAGES_PATH/kyleburton/bake-recipes.git
# @api.bake_url_to_package_path|ARGUMENTS
# @api.bake_url_to_package_path|  url - the url to convert
# @api.bake_url_to_package_path|RETURNS
# @api.bake_url_to_package_path|  0 on success
function bake_url_to_package_path () {
    local url
    url="$1"
    # strip the *:// if present
    # then see if it exists as $BAKE_PACKAGES_PATH/$url
    local fpath
    fpath=${url##*://}
    fpath=${fpath##git@}

    # Nuke the .git/ if left in path
    fpath=${fpath/.git\///}

    echo "$BAKE_PACKAGES_PATH/$fpath"
}

# @api.bake_git_to_url|DESCRPTION
# @api.bake_git_to_url|  converts a `git@host:org/path.git` git url to an `ssh://gt@host/org/path.git` url
# @api.bake_git_to_url|ARGUMENTS
# @api.bake_git_to_url|  url - the url to convert
# @api.bake_git_to_url|RETURNS
# @api.bake_git_to_url|  0 on success
function bake_git_to_url () {
    local url
    url="$1"
    local host
    local path

    [[ $url =~ git@(.*):(.*) ]] && host=${BASH_REMATCH[1]} && path=${BASH_REMATCH[2]}
    echo ssh://git@"${host}"/"${path}"
}

# @api.bake_sanitize_url|DESCRPTION
# @api.bake_sanitize_url|  if there is no schema, `https://` will be added, any traliing `/.git` suffix
# @api.bake_sanitize_url|  will be stripped.
# @api.bake_sanitize_url|ARGUMENTS
# @api.bake_sanitize_url|  url - the url to process
# @api.bake_sanitize_url|RETURNS
# @api.bake_sanitize_url|  0 on success
function bake_sanitize_url () {
    local url
    url="$1"

    # If no schema, assume it's https
    if [[ $url != *://* ]]; then
        url=https://${url}
    fi

    # Remove any .git in the url
    url=${url/.git\///}
    echo "$url"
}

# @api.bake_ensure_bake_packages_path|DESCRPTION
# @api.bake_ensure_bake_packages_path|  creates $BAKE_PACKAGES_PATH if it doesn't exist
# @api.bake_ensure_bake_packages_path|ARGUMENTS
# @api.bake_ensure_bake_packages_path|  none
# @api.bake_ensure_bake_packages_path|RETURNS
# @api.bake_ensure_bake_packages_path|  0 on success
function bake_ensure_bake_packages_path () {
    test -d "$BAKE_PACKAGES_PATH" || mkdir -p "$BAKE_PACKAGES_PATH"
}

# @api.bake_package_install|DESCRIPTION
# @api.bake_package_install|  install a git repo based package
# @api.bake_package_install|ARGUMENTS
# @api.bake_package_install|  url     - the git url, 'https://' and 'git@' urls are supported
# @api.bake_package_install|            the URL must point both to a valid git repository (that
# @api.bake_package_install|            can be cloned); and a file within the repository that
# @api.bake_package_install|            can be sourced.
# @api.bake_package_install|  tag     - optional tag or branch, defaults to 'master'
# @api.bake_package_install|EXAMPLE
# @api.bake_package_install|  bake_package_install https://github.com/kyleburton/bake/packages/bake/internal/test.sh
# @api.bake_package_install|RETURNS
# @api.bake_package_install|  0 on success
# @api.bake_package_install|  throws if unable to parse the URL
# @api.bake_package_install|  throws if the URL does not contain a file path
function bake_package_install () {
    local url tag schema git_project_name git_host_and_user bake_library_file git_url
    url="$1"
    tag="${2:-master}"
    schema=${url%%://*}

    if ! command -v git > /dev/null; then
        bake_throw "Error[bake_package_install] git command not found in PATH" EXIT
        exit 1
    fi

    bake_ensure_bake_packages_path
    pushd "$BAKE_PACKAGES_PATH" > /dev/null

    git_project_name=""
    git_host_and_user=""
    bake_library_file=""

    # full git style URL: https://user@host/org/path
    #   - host and user optionally contains user
    [[ $url =~ [a-zA-Z]+://([a-zA-Z0-9@-_.]+/[a-zA-Z0-9_-]+)/([a-zA-Z0-9_-]+)/(.*) ]] && \
        git_host_and_user=${BASH_REMATCH[1]} && \
        git_project_name=${BASH_REMATCH[2]} && \
        bake_library_file=${BASH_REMATCH[3]}

    if [[ -z "$git_host_and_user" ]] || [[ -z "$git_project_name" ]]; then
        bake_throw "Error[bake_package_install] Could not parse url '$url'"
        exit 1
    fi

    if [[ -z "$bake_library_file" ]]; then
        bake_throw "Error[bake_package_install] No library file specified"
        exit 1
    fi

    git_url=${git_host_and_user}/${git_project_name}
    git_host_and_user=${git_host_and_user##git@}
    test -d "$git_host_and_user" || mkdir -p "$git_host_and_user"
    cd "$git_host_and_user"

    if [[ ! -e "$git_project_name" ]]; then
        git clone "$schema://$git_url"
    fi

    # Checkout the project and branch/tag
    cd "$git_project_name"
    git checkout .
    git pull
    git checkout "$tag"
    popd > /dev/null
}

# @api.bake_require_from_url|DESCRIPTION
# @api.bake_require_from_url|  requires the library at url.  Bake will first attempt to install the
# @api.bake_require_from_url|  package, see `bake_package_install`
# @api.bake_require_from_url|ARGUMENTS
# @api.bake_require_from_url|  url - the url of the library (file) to require
# @api.bake_require_from_url|RETURNS
# @api.bake_require_from_url|  0 on success
function bake_require_from_url () {
    local url fspath
    url="$1"
    fspath="$(bake_url_to_package_path "$url")"

    if [ -e "$fspath" ]; then
        trap "bake_echo_red 'Error[bake_require_from_url] loading require: \$fspath'" EXIT
        # shellcheck disable=SC1090
        source "$fspath"
        trap EXIT # clear the trap
        return 0
    fi

    bake_package_install "$url"

    if [ ! -e "$fspath" ]; then
        bake_echo_red "Error[bake_require_from_url]: Sorry, after clone, fech and check out, $fspath still doesn't exist"
        bake_echo_red "Require not found: $url => $fspath"
    fi

    trap "bake_echo_red 'Error[bake_require_from_url] loading require: \$fspath'" EXIT
    # shellcheck disable=SC1090
    source "$fspath"
    trap EXIT # clear the trap
}

# @api.bake_require|DESCRIPTION
# @api.bake_require|  sources a library.  The library may be a local file path, a remote git url or an http url.
# @api.bake_require|  See bake_require_from_url for handling of remote urls, see bake_require_from_fs for
# @api.bake_require|  handling of local paths.
# @api.bake_require|ARGUMENTS
# @api.bake_require|  module - the module to require (a file, an http, https, or git url)
# @api.bake_require|RETURNS
# @api.bake_require|  0 on success
function bake_require () {
    local module
    module="$1"
    if bake_looks_like_url "$module"; then
        module="$(bake_sanitize_url "$module")"
        bake_require_from_url "$module"
    elif bake_looks_like_git "$module"; then
        module="$(bake_git_to_url "$module")"
        module="$(bake_sanitize_url "$module")"
        bake_require_from_url "$module"
    else
        bake_require_from_fs "$module"
    fi
}

# @api.bake_require_all|DESCRIPTION
# @api.bake_require_all|  requires all of the files located under path.  See `bake_require`
# @api.bake_require_all|  NB: this does not recurse.
# @api.bake_require_all|ARGUMENTS
# @api.bake_require_all|  path - the directory to require
# @api.bake_require_all|RETURNS
# @api.bake_require_all|  0 on success
function bake_require_all () {
    local path files
    path="$1"
    files="$(find "$path" -type f)"
    for f in $files; do
        bake_require "$f"
    done
}

# @api.bake_task|DESCRIPTION
# @api.bake_task|  registers a task
# @api.bake_task|ARGUMENTS
# @api.bake_task|  name        - the name of the task
# @api.bake_task|  short_desc  - the short description for the task
# @api.bake_task|RETURNS
# @api.bake_task|  0 on success
# bake_task taskname ["description"]
function bake_task () {
    local name short_desc
    name="${1:-}"
    short_desc="${2:-No Description for task: $name}"
    if [ -z "$name" ]; then
        echo "Error[bake_task]: you must supply a task name!"
        return 1
    fi
    BAKE_TASKS[$name]="ok"
    BAKE_TASK_DESCRIPTIONS[$name]="$short_desc"
    bake_log_internal "registering task '$name' - '$short_desc'"
    return 0
}

# @api.bake_task_short_desc|DESCRIPTION
# @api.bake_task_short_desc|  prints the first line of the short_desc registered for task. See `bake_task`
# @api.bake_task_short_desc|ARGUMENTS
# @api.bake_task_short_desc|  name  - the name of the task to retrieve the help text for.
# @api.bake_task_short_desc|RETURNS
# @api.bake_task_short_desc|  0 on success
function bake_task_short_desc () {
    local name="${1:-}"
    local descr
    descr="$(echo "${BAKE_TASK_DESCRIPTIONS[$name]:-}" | head -n 1)"
    echo "$descr" | head -n 1
}

# @api.bake_is_registered_task|DESCRIPTION
# @api.bake_is_registered_task|  check if a given name is a registered task, see `bake_task`
# @api.bake_is_registered_task|ARGUMENTS
# @api.bake_is_registered_task|  name - the task name to check
# @api.bake_is_registered_task|RETURNS
# @api.bake_is_registered_task|  0 on success
# @api.bake_is_registered_task|  1 of the name is not a registered task
function bake_is_registered_task () {
    local name
    name="$1"
    # for tname in "${!BAKE_TASKS[@]}"; do
    bake_log_internal "bake_sorted_task_list='$(bake_sorted_task_list)'"
    for tname in $(bake_sorted_task_list); do
        bake_log_internal "name=$name == tname=$tname"
        # >&2 echo "::bake_is_registered_task: tanme=$tname == name=$name"
        if [[ "$tname" == "$name" ]]; then
            return 0
        fi
    done

    bake_log_internal "not a registered task='$name'"
    return 1
}

# @api.bake_cd|DESCRIPTION
# @api.bake_cd|  changes directory to the given path, or the location of the Bakefile
# @api.bake_cd|ARGUMENTS
# @api.bake_cd|  path - the optional path to cd to
# @api.bake_cd|RETURNS
# @api.bake_cd|  0 on success
function bake_cd () {
    local path="${1:-}"
    if [ -z "$path" ]; then
        cd "$(dirname "$BAKEFILE")"
    else
        cd "$(dirname "$BAKEFILE")/$path"
    fi
}

# @api.bake_find_bakefile_impl|DESCRIPTION
# @api.bake_find_bakefile_impl|  locates the Bakefile using the following order
# @api.bake_find_bakefile_impl|  * ./Bakefile in the pwd
# @api.bake_find_bakefile_impl|  * ./bakefile in the pwd
# @api.bake_find_bakefile_impl|  * if ./bake is a folder
# @api.bake_find_bakefile_impl|  * if ./Bake is a folder
# @api.bake_find_bakefile_impl|  if none are found, it will step one directory up and try again,
# @api.bake_find_bakefile_impl|  repeating until it hits the root of the file system, where it will fail.
# @api.bake_find_bakefile_impl|ARGUMENTS
# @api.bake_find_bakefile_impl|  none
# @api.bake_find_bakefile_impl|RETURNS
# @api.bake_find_bakefile_impl|  0 on success, if a bake file or directory is found
# @api.bake_find_bakefile_impl|  1 if the root of the file system is reached ('/')
function bake_find_bakefile_impl () {
    local project_root
    project_root="$(pwd)"
    if [ -f "Bakefile" ]; then
        echo "$project_root/Bakefile"
        return 0
    fi

    if [ -f "bakefile" ]; then
        echo "$project_root/bakefile"
        return 0
    fi

    if [ -d "bake" ]; then
        echo "$project_root/bake"
        return 0
    fi

    if [ -d "Bake" ]; then
        echo "$project_root/Bake"
        return 0
    fi

    if [ "/" = "$(pwd)" ]; then
        echo ""
        return 1;
    fi

    cd ..
    bake_find_bakefile_impl
}

# @api.bake_find_bakefile|DESCRIPTION
# @api.bake_find_bakefile|  Returns $BAKEFILE if set, otherwise, saves $PWD into start_path, then
# @api.bake_find_bakefile|  calls `bake_find_bakefile_impl` to find the BAKEFILE, returning to
# @api.bake_find_bakefile|  start_path.
# @api.bake_find_bakefile|ARGUMENTS
# @api.bake_find_bakefile|  none
# @api.bake_find_bakefile|RETURNS
# @api.bake_find_bakefile|  0 on success
function bake_find_bakefile () {
    local start_path
    if [ -n "${BAKEFILE:-}" ]; then
        echo "$BAKEFILE"
        return 0
    fi

    start_path="$(pwd)"
    bake_find_bakefile_impl
    cd "$start_path" > /dev/null 2>&1
}

# @api.bake_inernal_help|DESCRIPTION
# @api.bake_inernal_help|  prints bake's internal help
# @api.bake_inernal_help|ARGUMENTS
# @api.bake_inernal_help|  none
# @api.bake_inernal_help|RETURNS
# @api.bake_inernal_help|  0 on success
function bake_inernal_help () {
    echo "$0 task [arg ...]"
    echo ""
    echo "Hi there!  Tasks are taken from the file Bakefile (or bakefile) in the $PWD."
    echo "You can specify an alternate Bakefile by setting BAKEFILE:"
    echo ""
    echo "  BAKEFILE=\"my.Bakefile\" bake"
    echo ""
    echo "The internal commands that bake supports are:"
    echo ""
    echo "   init        Creates a skeleton Bakefile"
    echo "   update      Updates libraries (see ~/.bake)."
    echo "   upgrade     Refreshes bake itself."
    echo "   version     Show the version of bake!"
}

# @api.bake_sorted_task_list|DESCRIPTION
# @api.bake_sorted_task_list|  returns the sorted list of registered tasks
# @api.bake_sorted_task_list|ARGUMENTS
# @api.bake_sorted_task_list|  none
# @api.bake_sorted_task_list|RETURNS
# @api.bake_sorted_task_list|  0 on success
function bake_sorted_task_list () {
    local tasks
    tasks="$(echo "${!BAKE_TASKS[@]}" | tr ' ' \\n | sort -u | tr \\n ' ')"
    echo "${tasks% *}"
}

# @api.bake_find_matching_tasks|DESCRIPTION
# @api.bake_find_matching_tasks|  prints a list of matching tasks (by substring)
# @api.bake_find_matching_tasks|ARGUMENTS
# @api.bake_find_matching_tasks|  unknown_task - the task substring to search for
# @api.bake_find_matching_tasks|RETURNS
# @api.bake_find_matching_tasks|  0 on success
function bake_find_matching_tasks () {
    local unknown_task matches
    unknown_task="${1:-}"
    matches=""
    for task in $(bake_sorted_task_list); do
        if [[ "$task" == *$unknown_task* ]]; then
            matches="$matches $task"
        fi
    done

    echo "$matches"
}

# @api.bake_show_matching_tasks|DESCRIPTION
# @api.bake_show_matching_tasks|  prints the list of matching tasks and descriptions, see `bake_find_matching_tasks`
# @api.bake_show_matching_tasks|ARGUMENTS
# @api.bake_show_matching_tasks|  unknown_task - the task substring to match
# @api.bake_show_matching_tasks|RETURNS
# @api.bake_show_matching_tasks| 0 on success
# @api.bake_show_matching_tasks| 1 if no matching tasks are found
function bake_show_matching_tasks () {
    local unknown_task matches
    unknown_task="${1:-}"
    matches="$(bake_find_matching_tasks "$unknown_task")"

    for task in $matches; do
        printf "  %-30s %s\\n" "$task" "$(bake_task_short_desc "$task")"
    done

    if [ -z "$matches" ]; then
        return 1
    else
        return 0
    fi
}

# @api.bake_show_all_tasks|DESCRIPTION
# @api.bake_show_all_tasks|  shows all tasks and descriptions
# @api.bake_show_all_tasks|ARGUMENTS
# @api.bake_show_all_tasks|  none
# @api.bake_show_all_tasks|RETURNS
# @api.bake_show_all_tasks|  0 on success
function bake_show_all_tasks () {
    for task in $(bake_sorted_task_list); do
        printf "  %-30s %s\\n" "$task" "$(bake_task_short_desc "$task")"
    done
}

# @api.bake_show_task_help|DESCRIPTION
# @api.bake_show_task_help|  prints the help text for a task
# @api.bake_show_task_help|ARGUMENTS
# @api.bake_show_task_help|  task - the name of the registered task to show the help for
# @api.bake_show_task_help|RETURNS
# @api.bake_show_task_help|  0 on success
function bake_show_task_help () {
    local task line
    task="$1"
    printf "\\n"
    printf "%s - %s\\n" "$task" "$(bake_task_short_desc "$task")"
    printf "\\n"
    grep "^# @help.$task|" "$BAKEFILE" | while read -r line; do
        echo "${line#*|}"
    done
    printf "\\n"
}

# @api.bake_bakefile_help|DESCRIPTION
# @api.bake_bakefile_help|  displays detailed help for a registered task, brief help for matching tasks (by substring,
# @api.bake_bakefile_help|  see `bake_show_matching_tasks`) or the list of all registerd tasks.
# @api.bake_bakefile_help|ARGUMENTS
# @api.bake_bakefile_help|  unknown_task - optional task name to display help for
# @api.bake_bakefile_help|RETURNS
# @api.bake_bakefile_help|  0 on success
function bake_bakefile_help () {
    local unknown_task is_registered
    unknown_task="${1:-}"
    is_registered=""

    if [[ "$unknown_task" == help ]]; then
        shift
        unknown_task="${1:-}"
        bake_log_internal "::unknown_task was help, re-grabbed \$1 = '$unknown_task'"
    fi

    if bake_is_registered_task "$unknown_task"; then
        is_registered="registered"
    fi

    # echo "::is_registered:unknown_task = '$is_registered:$unknown_task'"
    case "$is_registered:$unknown_task" in
        registered:*)
            # echo "::MATCH: is_registered:unknown_task = '$is_registered:$unknown_task'"
            bake_log_internal "task='$unknown_task' is registered, showing specific help"
            bake_show_task_help "$unknown_task"
            ;;
        :*)
            bake_log_internal "task='$unknown_task' is not registerd, showing matching tasks"
            bake_show_matching_tasks "$unknown_task"
            ;;
        *)
            echo ""
            echo "$0 task [arg ...]"
            echo ""
            bake_show_all_tasks
            ;;
    esac

    return 1
}

# @api.bake_api_help|DESCRIPTION
# @api.bake_api_help|  display api help
# @api.bake_api_help|ARGUMENTS
# @api.bake_api_help|  api function to display help for
# @api.bake_api_help|RETURNS
# @api.bake_api_help|
function bake_api_help () {
    local apifn stdoutfilter
    apifn="${1:-}"

    bake_log_internal "apifn='$apifn'"

    if [[ -n "$apifn" ]]; then
        echo "NAME"
        echo "  $apifn"
        grep "^# @api.$apifn|" "$0" | cut -f2 -d\|
        return 0
    fi

    stdoutfilter="cat"

    if [[ "$BAKE_STDOUT_IS_TERMINAL" == yes ]]; then
        stdoutfilter="less"
    fi

    for apifn in $(grep "^# @api." "$0" | cut -f1 -d\| | cut -f2 -d. | sort -u); do
        echo "NAME"
        echo "  $apifn"
        grep "^# @api.$apifn|" "$0" | cut -f2 -d\|
        echo ""
        echo ""
    done | "$stdoutfilter"
}

# @api.bake_upgrade|DESCRIPTION
# @api.bake_upgrade|  downloads (via curl) bake from $BAKE_URL, overwriting `bake`
# @api.bake_upgrade|ARGUMENTS
# @api.bake_upgrade|  none
# @api.bake_upgrade|RETURNS
# @api.bake_upgrade|  0 on success
function bake_upgrade () {
    curl -o "$0.new" "$BAKE_URL"
    chmod 755 "$0.new"
    mv "$0.new" "$0"
}

# @api.bake_version|DESCRIPTION
# @api.bake_version|  prints the version of bake
# @api.bake_version|ARGUMENTS
# @api.bake_version|  none
# @api.bake_version|RETURNS
# @api.bake_version|  0 on success
function bake_version () {
    echo "$BAKE_VERSION"
}

# @api.bake_update|DESCRIPTION
# @api.bake_update|  attempts to update all packages installed in $HOME/.bake/pacakges
# @api.bake_update|ARGUMENTS
# @api.bake_update|  none
# @api.bake_update|RETURNS
# @api.bake_update|  0 on success
function bake_update () {
    if [ ! -d "$HOME/.bake/packages" ]; then
        bake_echo_yellow "No libraries found in ~/.bake, nothing to upgrade"
        exit 0
    fi

    cd "$HOME/.bake/packages"
    local dirs
    dirs="$(find . -name .git -type d)"
    for path in $dirs; do
        local dname
        dname="$(dirname "$path")"
        bake_echo_green "UPDATE: $path => $dname"
        pushd "$dname"
        git checkout .
        git pull
        popd > /dev/null
    done
}

# @api.bake_create_bakefile|DESCRIPTION
# @api.bake_create_bakefile|  creates a skeleton bakefile in the current directory, unless one exists
# @api.bake_create_bakefile|ARGUMENTS
# @api.bake_create_bakefile|  none
# @api.bake_create_bakefile|RETURNS
# @api.bake_create_bakefile|  0 on success
# @api.bake_create_bakefile|  1 if there is already a bakefile
function bake_create_bakefile () {
    if [ ! -e "Bakefile" ]; then
        cat > "Bakefile" <<'END'
#!/usr/bin/env bash

# bake_require github.com/kyleburton/bake-recipes/docker/docker.sh

# Set default editor if not defined
export EDITOR="${EDITOR:-vi}"

# @help.get-started|This is an example task, here's where the fun begins.
# @help.get-started|(right now it launches $EDITOR on Bakefile, best of luck
# @help.get-started| getting out of it ... https://stackoverflow.blog/2017/05/23/stack-overflow-helping-one-million-developers-exit-vim/)
bake_task get-started "Get started by editing this Bakefile"
function get-started () {
    "$EDITOR" Bakefile
}
END
    else
        return 1
    fi
}

# @api.bake_source_bakefile|DESCRIPTION
# @api.bake_source_bakefile|  sources the bakefile to register available tasks
# @api.bake_source_bakefile|ARGUMENTS
# @api.bake_source_bakefile|  bakefile - the bakefile
# @api.bake_source_bakefile|RETURNS
# @api.bake_source_bakefile|  0 on success
function bake_source_bakefile () {
    local bakefile
    bakefile="$1"
    if [[ -d $bakefile ]]; then
        for f in "$bakefile"/*; do
            bake_log_internal "sourcing from dir[$bakefile] '$f'"
            bake_source_bakefile "$f"
        done
        return 0
    fi

    bake_log_internal "sourcing bakefile '$bakefile'"
    # shellcheck disable=SC1090
    source "$bakefile"
}

# @api.bake_run|DESCRIPTION
# @api.bake_run|  this is the "main" function of bake, which will run the named task,
# @api.bake_run|  the default task, or dispkay help.
# @api.bake_run|OPTIONS
# @api.bake_run|  --init              - create a skeleton bakefile in the current
# @api.bake_run|                        directory, see `bake_create_bakefile`.
# @api.bake_run|  --log-level=LEVEL   - sets the log level, LEVEL may be any of
# @api.bake_run|                        internal, debug, info, warn, error, fatal, or none
# @api.bake_run|  --upgrade           - attempts to upgrade bake, see `bake_upgrade`
# @api.bake_run|  --version           - prints the version of bake
# @api.bake_run|ARGUMENTS
# @api.bake_run|  task     - the name of the task to execute
# @api.bake_run|RETURNS
# @api.bake_run|  0 on success
# @api.bake_run|  1 on failure
# @api.bake_run|  * the return value of the executed task
function bake_run () {
    local task

    local bakefile
    bakefile="$(bake_find_bakefile)"

    if [ ! -e "$bakefile" ]; then
        echo "Error[bake_run]: could not locate a Bakefile!"
        echo ""
        bake_inernal_help
        return 1
    fi

    BAKEFILE="$bakefile"
    # export BAKEFILE

    while [[ "${1:-}" == --* ]]; do
        case "$1" in
            --init)
                shift
                bake_create_bakefile
                return 0
                ;;
            --log-level=*)
                bake_log_level "${1#*=}"
                shift
                ;;
            --upgrade)
                shift
                bake_upgrade
                return 0
                ;;
            --version)
                shift
                bake_version
                return 0
                ;;
            *)
                echo "bake:Error: unrecognized option: '$1'"
                return 1
                ;;
        esac
    done

    task="${1:-}"
    if [ -n "$task" ]; then
        bake_log_internal "task passed to bake_run='$task'"
        shift
    fi

    bake_source_bakefile "$bakefile"

    if [ -n "$task" ]; then
        bake_log_internal "have task='$task'"
        if bake_is_registered_task "$task"; then
            bake_log_internal "task is regsitered, executing='$task' with args '$*'"
            $task "$@"
            exit $?
        fi

        bake_log_internal "check if we have an internal task='$task'"
        case "$task" in
            api)     bake_api_help "$@" ; return 0 ;;
            upgrade) bake_upgrade  "$@" ; return 0 ;;
            update)  bake_update   "$@" ; return 0 ;;
        esac

        bake_log_internal "not internal, unregistered task='$task', showing help"
        bake_bakefile_help "$task" "$@"
        exit 1
    fi

    if [ -n "$BAKE_DEFAULT_TASK" ]; then
        bake_log_internal "falling back to default=$BAKE_DEFAULT_TASK"
        "$BAKE_DEFAULT_TASK" "$@"
        exit $?
    fi

    bake_log_internal "fell through, displaygin help"
    bake_bakefile_help "$@"
    exit 1
}


# @api.bake_is_main|DESCRIPTION
# @api.bake_is_main|  detect if the script is being run or being sourced, see:
# @api.bake_is_main|  http://stackoverflow.com/questions/2683279/how-to-detect-if-a-script-is-being-sourced
# @api.bake_is_main|ARGS
# @api.bake_is_main|  none
# @api.bake_is_main|RETURNS
# @api.bake_is_main|  0 if bake is being run
# @api.bake_is_main|  1 if bake is being sourced
function bake_is_main () {
    test "${FUNCNAME[1]}" = "main"
}

# @api.bake_init|DESCRIPTION
# @api.bake_init|  initialize bake, sets terminal colors if stdout is a terminal.
# @api.bake_init|ARGS
# @api.bake_init|  none
# @api.bake_init|RETURNS
# @api.bake_init|  0 on success
function bake_init () {
    if [ -t 1 ]; then
        BAKE_STDOUT_IS_TERMINAL="yes"
        BAKE_COLOR_NORMAL="\\e[00m"
        BAKE_COLOR_RED="\\e[00;31m"
        BAKE_COLOR_LRED="\\e[01;31m"
        BAKE_COLOR_BLUE="\\e[00;34m"
        BAKE_COLOR_LBLUE="\\e[01;34m"
        BAKE_COLOR_GREEN="\\e[00;32m"
        BAKE_COLOR_LGREEN="\\e[01;32m"
        BAKE_COLOR_YELLOW="\\e[00;33m"
        BAKE_COLOR_MAGENTA="\\e[00;35m"
        BAKE_COLOR_LMAGENTA="\\e[00;95m"
        BAKE_COLOR_CYAN="\\e[00;36m"
        BAKE_COLOR_LCYAN="\\e[00;96m"
        BAKE_COLOR_LGRAY="\\e[00;37m"
        BAKE_COLOR_DGRAY="\\e[00;90m"

        export BAKE_STDOUT_IS_TERMINAL
    fi
}

# @api.bake_color_echo|DESCRIPTION
# @api.bake_color_echo|  echo using termianl escape colors if stdout is a terminal
# @api.bake_color_echo|ARGS
# @api.bake_color_echo|  color - the escape codes for the color to set
# @api.bake_color_echo|  *     - all other options are passed to `echo`
# @api.bake_color_echo|RETURNS
# @api.bake_color_echo|  0 on success
function bake_color_echo () {
    local color="$1"
    local opts="-e"
    shift
    while [[ "$1" == -* ]]; do
        opts="$opts $1"
        shift
    done
    echo "$opts" " " "${color}$*${BAKE_COLOR_NORMAL}"
}

# @api.bake_echo_red|DESCRIPTION
# @api.bake_echo_red|  echo the string in red
# @api.bake_echo_red|ARGS
# @api.bake_echo_red|  * - all arguments are passed to `bake_color_echo`
# @api.bake_echo_red|RETURNS
# @api.bake_echo_red|  0 on success
function bake_echo_red      () {
    bake_color_echo "$BAKE_COLOR_RED" "$@"
}

# @api.bake_echo_lred|DESCRIPTION
# @api.bake_echo_lred|  echo the string in light red
# @api.bake_echo_lred|ARGS
# @api.bake_echo_lred|  * - all arguments are passed to `bake_color_echo`
# @api.bake_echo_lred|RETURNS
# @api.bake_echo_lred|  0 on success
function bake_echo_lred     () {
    bake_color_echo "$BAKE_COLOR_LRED" "$@"
}

# @api.bake_echo_blue|DESCRIPTION
# @api.bake_echo_blue|  echo the string in blue
# @api.bake_echo_blue|ARGS
# @api.bake_echo_blue|  * - all arguments are passed to `bake_color_echo`
# @api.bake_echo_blue|RETURNS
# @api.bake_echo_blue|  0 on success
function bake_echo_blue     () {
    bake_color_echo "$BAKE_COLOR_BLUE" "$@"
}

# @api.bake_echo_lblue|DESCRIPTION
# @api.bake_echo_lblue|  echo the string in light blue
# @api.bake_echo_lblue|ARGS
# @api.bake_echo_lblue|  * - all arguments are passed to `bake_color_echo`
# @api.bake_echo_lblue|RETURNS
# @api.bake_echo_lblue|  0 on success
function bake_echo_lblue    () {
    bake_color_echo "$BAKE_COLOR_LBLUE" "$@"
}

# @api.bake_echo_green|DESCRIPTION
# @api.bake_echo_green|  echo the string in green
# @api.bake_echo_green|ARGS
# @api.bake_echo_green|  * - all arguments are passed to `bake_color_echo`
# @api.bake_echo_green|RETURNS
# @api.bake_echo_green|  0 on success
function bake_echo_green    () {
    bake_color_echo "$BAKE_COLOR_GREEN" "$@"
}

# @api.bake_echo_lgreen|DESCRIPTION
# @api.bake_echo_lgreen|  echo the string in light green
# @api.bake_echo_lgreen|ARGS
# @api.bake_echo_lgreen|  * - all arguments are passed to `bake_color_echo`
# @api.bake_echo_lgreen|RETURNS
# @api.bake_echo_lgreen|  0 on success
function bake_echo_lgreen   () {
    bake_color_echo "$BAKE_COLOR_LGREEN" "$@"
}

# @api.bake_echo_yellow|DESCRIPTION
# @api.bake_echo_yellow|  echo the string in yellow
# @api.bake_echo_yellow|ARGS
# @api.bake_echo_yellow|  * - all arguments are passed to `bake_color_echo`
# @api.bake_echo_yellow|RETURNS
# @api.bake_echo_yellow|  0 on success
function bake_echo_yellow   () {
    bake_color_echo "$BAKE_COLOR_YELLOW" "$@"
}

# @api.bake_echo_magenta|DESCRIPTION
# @api.bake_echo_magenta|  echo the string in magenta
# @api.bake_echo_magenta|ARGS
# @api.bake_echo_magenta|  * - all arguments are passed to `bake_color_echo`
# @api.bake_echo_magenta|RETURNS
# @api.bake_echo_magenta|  0 on success
function bake_echo_magenta  () {
    bake_color_echo "$BAKE_COLOR_MAGENTA" "$@"
}

# @api.bake_echo_lmagenta|DESCRIPTION
# @api.bake_echo_lmagenta|  echo the string in light magenta
# @api.bake_echo_lmagenta|ARGS
# @api.bake_echo_lmagenta|  * - all arguments are passed to `bake_color_echo`
# @api.bake_echo_lmagenta|RETURNS
# @api.bake_echo_lmagenta|  0 on success
function bake_echo_lmagenta () {
    bake_color_echo "$BAKE_COLOR_LMAGENTA" "$@"
}

# @api.bake_echo_cyan|DESCRIPTION
# @api.bake_echo_cyan|  echo the string in cyan
# @api.bake_echo_cyan|ARGS
# @api.bake_echo_cyan|  * - all arguments are passed to `bake_color_echo`
# @api.bake_echo_cyan|RETURNS
# @api.bake_echo_cyan|  0 on success
function bake_echo_cyan     () {
    bake_color_echo "$BAKE_COLOR_CYAN" "$@"
}

# @api.bake_echo_lcyan|DESCRIPTION
# @api.bake_echo_lcyan|  echo the string in light cyan
# @api.bake_echo_lcyan|ARGS
# @api.bake_echo_lcyan|  * - all arguments are passed to `bake_color_echo`
# @api.bake_echo_lcyan|RETURNS
# @api.bake_echo_lcyan|  0 on success
function bake_echo_lcyan    () {
    bake_color_echo "$BAKE_COLOR_LCYAN" "$@"
}

# @api.bake_echo_lgray|DESCRIPTION
# @api.bake_echo_lgray|  echo the string in light gray
# @api.bake_echo_lgray|ARGS
# @api.bake_echo_lgray|  * - all arguments are passed to `bake_color_echo`
# @api.bake_echo_lgray|RETURNS
# @api.bake_echo_lgray|  0 on success
function bake_echo_lgray    () {
    bake_color_echo "$BAKE_COLOR_LGRAY" "$@"
}

# @api.bake_echo_dgray|DESCRIPTION
# @api.bake_echo_dgray|  echo the string in dark gray
# @api.bake_echo_dgray|ARGS
# @api.bake_echo_dgray|  * - all arguments are passed to `bake_color_echo`
# @api.bake_echo_dgray|RETURNS
# @api.bake_echo_dgray|  0 on success
function bake_echo_dgray    () {
    bake_color_echo "$BAKE_COLOR_DGRAY" "$*"
}

# @api.bake_log|bake_log LNUM LNAME
# @api.bake_log|logging function implementation, LNUM is the log level number, LNAME is the string name.
# @api.bake_log|
# @api.bake_log| LNUM should be one of:
# @api.bake_log|   $BAKE_LOG_LEVEL_INTERNAL
# @api.bake_log|   $BAKE_LOG_LEVEL_DEBUG
# @api.bake_log|   $BAKE_LOG_LEVEL_INFO
# @api.bake_log|   $BAKE_LOG_LEVEL_WARN
# @api.bake_log|   $BAKE_LOG_LEVEL_ERROR
# @api.bake_log|   $BAKE_LOG_LEVEL_FATAL
# @api.bake_log|
# @api.bake_log| LNAME should be one of the following:
# @api.bake_log|
# @api.bake_log|   "INTERNAL" nb: internal will cause bake's internal logging to be emitted (hint, it may be a lot)
# @api.bake_log|   "DEBUG"
# @api.bake_log|   "INFO"
# @api.bake_log|   "WARN"
# @api.bake_log|   "ERROR"
# @api.bake_log|   "FATAL"
# @api.bake_log|
function bake_log () {
    local lnum lname
    lnum="$1"  ; shift
    lname="$1" ; shift
    [[ "$BAKE_LOG_LEVEL" -lt "$lnum" ]] && return 0
    echo "[$lname ${BAKEFILE:-}:${BASH_LINENO[1]}:${FUNCNAME[2]}] $*"
}

# @api.bake_log_internal|DESCRIPTION
# @api.bake_log_internal|  log at internal level
# @api.bake_log_internal|ARGUMENTS
# @api.bake_log_internal|  * all arguments are passed to `bake_log`
# @api.bake_log_internal|RETURNS
# @api.bake_log_internal|  0 on success
function bake_log_internal () { bake_log "$BAKE_LOG_LEVEL_INTERNAL" "INTERNAL" "$*"; }

# @api.bake_log_debug|DESCRIPTION
# @api.bake_log_debug|  log at debug level
# @api.bake_log_debug|ARGUMENTS
# @api.bake_log_debug|  * all arguments are passed to `bake_log`
# @api.bake_log_debug|RETURNS
# @api.bake_log_debug|  0 on success
function bake_log_debug () { bake_log "$BAKE_LOG_LEVEL_DEBUG" "DEBUG" "$*"; }

# @api.bake_log_info|DESCRIPTION
# @api.bake_log_info|  log at info level
# @api.bake_log_info|ARGUMENTS
# @api.bake_log_info|  * all arguments are passed to `bake_log`
# @api.bake_log_info|RETURNS
# @api.bake_log_info|  0 on success
function bake_log_info  () { bake_log "$BAKE_LOG_LEVEL_INFO"  "INFO"  "$*"; }

# @api.bake_log_warn|DESCRIPTION
# @api.bake_log_warn|  log at warn level
# @api.bake_log_warn|ARGUMENTS
# @api.bake_log_warn|  * all arguments are passed to `bake_log`
# @api.bake_log_warn|RETURNS
# @api.bake_log_warn|  0 on success
function bake_log_warn  () { bake_log "$BAKE_LOG_LEVEL_WARN"  "WARN"  "$*"; }

# @api.bake_log_error|DESCRIPTION
# @api.bake_log_error|  log at error level
# @api.bake_log_error|ARGUMENTS
# @api.bake_log_error|  * all arguments are passed to `bake_log`
# @api.bake_log_error|RETURNS
# @api.bake_log_error|  0 on success
function bake_log_error () { bake_log "$BAKE_LOG_LEVEL_ERROR" "ERROR" "$*"; }

# @api.bake_log_fatal|DESCRIPTION
# @api.bake_log_fatal|  log at fatal level
# @api.bake_log_fatal|ARGUMENTS
# @api.bake_log_fatal|  * all arguments are passed to `bake_log`
# @api.bake_log_fatal|RETURNS
# @api.bake_log_fatal|  0 on success
function bake_log_fatal () { bake_log "$BAKE_LOG_LEVEL_FATAL" "FATAL" "$*"; }

# @api.bake_throw|DESCRIPTION
# @api.bake_throw|  "throw" an exception, this will print the arguments and a stacktrace.
# @api.bake_throw|ARGUMENTS
# @api.bake_throw|  * all arguments will be printed
# @api.bake_throw|RETURNS
# @api.bake_throw|  1
function bake_throw () {
    local lnum fnum lineno funcname
    echo "EXCEPTION: $*"
    lnum=0
    fnum=1
    while : ; do
        lineno="${BASH_LINENO[$lnum]}"
        if [[ -z "$lineno" || "$lineno" == 0 ]]; then
            break
        fi

        # echo "about to get funcname, lnum=$lnum; fnum=$fnum; lineno=$lineno"
        funcname="${FUNCNAME[$fnum]}"
        echo "  ${BAKEFILE:-}:$lineno:$funcname"
        lnum=$(( lnum + 1 ))
        fnum=$(( fnum + 1 ))
    done
    return 1
}

# @api.bake_log_level|bake_log_level LEVEL
# @api.bake_log_level|Sets the log level to LEVEL, LEVEL must be one of the following:
# @api.bake_log_level|
# @api.bake_log_level| debug
# @api.bake_log_level| info
# @api.bake_log_level| warn
# @api.bake_log_level| eerror
# @api.bake_log_level| fatal
# @api.bake_log_level| none    - disables logging
# @api.bake_log_level|
function bake_log_level () {
    local level="$1"
    case "$level" in
        internal)
            export BAKE_LOG_LEVEL="$BAKE_LOG_LEVEL_INTERNAL"
            ;;
        debug)
            export BAKE_LOG_LEVEL="$BAKE_LOG_LEVEL_DEBUG"
            ;;
        info)
            export BAKE_LOG_LEVEL="$BAKE_LOG_LEVEL_INFO"
            ;;
        warn)
            export BAKE_LOG_LEVEL="$BAKE_LOG_LEVEL_WARN"
            ;;
        error)
            export BAKE_LOG_LEVEL="$BAKE_LOG_LEVEL_ERROR"
            ;;
        fatal)
            export BAKE_LOG_LEVEL="$BAKE_LOG_LEVEL_FATAL"
            ;;
        none)
            export BAKE_LOG_LEVEL="$BAKE_LOG_LEVEL_NONE"
            ;;
        *)
            bake_log_error "invalid log level='$level'"
            return 1
            ;;
    esac
}

bake_init

if bake_is_main; then
    bake_run "$@"
fi

# see: https://wilkesley.org/~ian/xah/emacs/elisp_run_elisp_when_file_opens.html
# Local Variables:
# eval: (load-file "~/code/github.com/kyleburton/bake/support/bakefile-mode.el")
# End:
